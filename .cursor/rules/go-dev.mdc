---
alwaysApply: true
---
ROLE
You are an AI developer working on a Go service using chi with a layered architecture (handler/service/repo), JWT authentication, and RBAC. Always follow the practices below.

ALWAYS-DO PRACTICES
1) For any code change, run the full format → lint → test → build → restart cycle:
   - make fmt                # auto-fix formatting/imports
   - make lint               # fix all findings; rerun until clean
   - make test
   - make test-integration
   - make dev-reset
2) Do not rely on hot reload: Go applies code changes only after a full restart.
3) Every commit/PR must pass: fmt → lint → test → build (in that order).

REGISTERING NEW ENDPOINTS (WHEN ADDING A RESOURCE)
A) Update the API endpoints list:
   - File: internal/app/server.go (the r.Get("/") handler returning "API v1").
   - Add "/{resource}" to the "endpoints" array in the JSON response.

B) Register routes (after the main routing block). Use this template:
   // Protected {resource} management
   r.Route("/{resource}", func(r chi.Router) {
       repo := pg.New{PascalResource}Repository(db.GetPool())
       svc  := service.New{PascalResource}Service(repo)
       h    := httpmiddleware.New{PascalResource}Handler(svc)

       jwt    := auth.NewDefaultJWTManager(cfg.Auth.JWTSecret)
       authMW := httpmiddleware.NewAuthMiddleware(jwt)
       rbacMW := httpmiddleware.NewRBACMiddleware()

       // Require authentication for all routes
       r.Use(authMW.RequireAuth)

       // Read endpoints — for all authenticated users with read access
       r.With(rbacMW.RequireReadAccess).Group(func(r chi.Router) {
           r.Get("/", h.ListItems)
           r.Get("/{id}", h.GetItem)
       })

       // Write endpoints — ADMIN and DISPATCHER only
       r.With(rbacMW.RequireWriteAccess).Group(func(r chi.Router) {
           r.Post("/", h.CreateItem)
           r.Put("/{id}", h.UpdateItem)
           r.Delete("/{id}", h.DeleteItem)
           r.Post("/{id}/restore", h.RestoreItem)
       })
   })

C) Create/maintain layer files:
   - Handler:   internal/adapter/http/{resource}_handler.go
   - Service:   internal/service/{resource}_service.go
   - Repository: internal/adapter/repo/pg/{resource}_repo.go
   - Models:    internal/models/{resource}.go
   - Ports:     internal/port/{resource}_repo.go, internal/port/{resource}_service.go
   Requirements:
   - Use context, validate inputs, return correct HTTP status codes.
   - Handle and log errors at handler/service levels (useful, non-leaky messages).
   - Support soft-delete/restore where the domain model requires it.

MANDATORY TESTING (AFTER ANY NEW FUNCTIONALITY)
1) Unit tests (required):
   - Add *_test.go for handler/service/repo with happy-path and failure cases.
   - Cover RBAC (read/write), 401/403, 404, validation, soft-delete/restore.
   Command:
   - make test

2) Integration/HTTP tests (required):
   - Use httptest for the router or run end-to-end against the dev environment.
   - Scenarios: list, get, create, update, delete, restore; auth and access errors.

3) Manual HTTP verification (required):
   # Check root endpoints list
   curl -s http://localhost:8080/api/v1/ | jq .

   # Get admin token
   TOKEN=$(curl -s -X POST http://localhost:8080/api/v1/auth/login \
     -H "Content-Type: application/json" \
     -d '{"email":"admin@example.com","password":"admin123456"}' | \
     grep -o '"accessToken":"[^"]*"' | cut -d'"' -f4)

   # Verify the new resource
   curl -s -H "Authorization: Bearer $TOKEN" \
     http://localhost:8080/api/v1/{resource} | jq .

   - Ensure the endpoint is present in the root list and responds correctly.

BEFORE COMPLETING ANY TASK (REQUIRED COMMANDS)
1) make fmt
2) make lint
3) make test
4) make test-db-stop test-db test-integration
5) make dev-reset
6) Re-run the manual curl checks (see above)

EXPECTED OUTPUTS AFTER CHANGES
- List of created/modified files.
- Minimal necessary code diffs/snippets per file.
- Results of make fmt / make lint (clean).
- Results of go test and make test; integration results (make dev-reset).
- Restart commands executed and confirmation of successful start.
- Curl response snippets (or a brief error + fix description).

NEVER-DO PRACTICES
- Do not expect changes to apply without a full dev restart.
- Do not restart only the DB (make db) and assume the Go app updated.
- Do not commit code that fails lint, lacks fmt, or lacks tests.
- Do not forget to add the new route to the API info endpoints list.
- Do not skip RBAC and edge-case tests (401/403/404/422, etc.).
- Do not include mocks/fakes in production code. Keep mocks strictly in tests:
  - Place them in *_test.go or in /test-only packages.
  - If needed, protect with build tags (e.g., //go:build test) so they never compile into production builds.

NOTES
- Follow local naming conventions; keep imports clean (gofmt/goimports).
- Log and error messages must aid diagnosis without exposing sensitive details.
